#!/bin/bash
#+
# This script invokes Blender to import a 3D model in a supported
# format into a new .blend file. Invoke it as follows:
#
#     import_to_blender [«options»...] «input_file» «output_blend_file»
#
# where «input_file» is the name of the file to import, and
# «output_blend_file» is the name to give the output .blend file.
#
# Valid options are
#    --arg=«keyword»=«value»
#          specifies an additional keyword argument for the import operator.
#          May be specified multiple times with different keywords.
#    --blender=«blender»
#          specifies the path to the Blender executable. Defaults to
#          searching for the name “blender” in your PATH.
#    --existing=error|overwrite
#          specifies what to do if the output .blend file already exists:
#            error       -- signal an error and abort the conversion (default)
#            overwrite   -- overwrite the output .blend file
#    --postexec=script
#          executes the specified Python code after the import, just prior
#          to saving the .blend file.
#          May be specified multiple times; the values are concatenated
#          in sequence, separated by newlines.
#    --preexec=script
#          executes the specified Python code prior to the import.
#          May be specified multiple times; the values are concatenated
#          in sequence, separated by newlines.
#    --scale=«scalefactor»
#          specifies an optional factor by which to scale the imported
#          model.
#    --template=«template-name»
#          specifies the startup template to load before doing the import.
#
# External program needed: unar.
#
# Copyright 2018 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

opterror()
  {
    echo "$0: $1" 1>&2
    exit 3
  } # opterror

blender=blender
existing=error
nr_args=0
args=
scale=
template=
postexec=
preexec=

for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    if [ "$1" == "--" ]; then
        shift
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "arg" ]; then
        nr_args=$((nr_args + 1))
        export IMPORT_arg_${nr_args}="$val"
    elif [ "$opt" = "blender" ]; then
        blender="$val"
    elif [ "$opt" = "existing" ]; then
        if [ "$val" != "error" -a "$val" != "overwrite" ]; then
            opterror "--existing value must be “error” or “overwrite”"
        fi
        existing="$val"
    elif [ "$opt" = "postexec" ]; then
        if [ -n "$postexec" ]; then
            postexec="$postexec"$'\n'"$val"
        else
            postexec="$val"
        fi
    elif [ "$opt" = "preexec" ]; then
        if [ -n "$preexec" ]; then
            preexec="$preexec"$'\n'"$val"
        else
            preexec="$val"
        fi
    elif [ "$opt" = "scale" ]; then
        scale="$val"
    elif [ "$opt" = "template" ]; then
        template="$val"
    else
        opterror "bad option $opt"
    fi
done
if [ -z "$(type -p "$blender")" ]; then
    opterror "no such executable “$blender”"
fi
if [ $# != 2 ]; then
    opterror $'Usage:\n\t'"$0 "'«input_to_blender» «output_blend_file»'
fi

# pass parameters to Python script in environment variables to avoid
# problems with special characters
export IMPORT_infile="$1"
export IMPORT_outfile="$2"
export IMPORT_existing="$existing"
if [ $nr_args -ne 0 ]; then
    unset IMPORT_arg_$((nr_args + 1)) # just in case
fi
export IMPORT_scale="$scale"
export IMPORT_template="$template"
export IMPORT_postexec="$postexec"
export IMPORT_preexec="$preexec"

exec "$blender" -noaudio -b -P <(cat <<'EOD'
import sys
import os
import subprocess
import shutil
import tempfile
import getopt
import bpy

try :
    os.wait() # gobble zombie child of shell which was previously in this process slot
except ChildProcessError :
    # can happen intermittently?
    pass
#end try

def valid_axis(arg) :
    if arg not in {"X", "Y", "Z", "-X", "-Y", "-Z"} :
        raise TypeError("not a valid axis: %s" % repr(arg))
    #end if
    return \
        arg
#end valid_axis

def limit_int(minval, maxval) :

    maxval_str = (lambda : "∞", lambda : "%d" % maxval)[maxval != None]()

    def validate(arg) :
        arg = int(arg)
        if arg < minval or maxval != None and arg > maxval :
            raise TypeError("arg %d out of range [%d, %s]" % (arg, minval, maxval_str))
        #end if
        return \
            arg
    #end validate

#begin limit_int
    validate.__name__ = "limit_int(%d, %s)" % (minval, maxval_str)
    return \
        validate
#end limit_int

def limit_float(minval, maxval) :

    def validate(arg) :
        arg = float(arg)
        if arg < minval or arg > maxval :
            raise TypeError("arg %.3g out of range [%.3g, %.3g]" % (arg, minval, maxval))
        #end if
        return \
            arg
    #end validate

#begin limit_float
    validate.__name__ = "limit_float(%.3g, %.3g)" % (minval, maxval)
    return \
        validate
#end limit_float

def limit_enum(vals) :

    def validate(arg) :
        if arg not in vals :
            raise TypeError("value %s not in %s" % (repr(arg), repr(sorted(vals))))
        #end if
        return \
            arg
    #end validate

#begin limit_enum
    validate.__name__ = "limit_enum(%s)" % repr(sorted(vals))
    return \
        validate
#end limit_enum

importers = \
    {
        ".3ds" :
            {
                "name" : "3DS",
                "op" : bpy.ops.import_scene.autodesk_3ds,
                "args" :
                    [
                        ("axis_forward", valid_axis),
                        ("axis_up", valid_axis),
                        ("constrain_size", limit_float(0, 1000)),
                        ("use_image_search", bool),
                        ("use_apply_transform", bool),
                    ],
            },
        ".abc" :
            {
                "name" : "Alembic",
                 "op" : bpy.ops.wm.alembic_import,
                "args" :
                    [
                        ("scale", limit_float(0.0001, 1000)),
                        ("set_frame_range", bool),
                        ("validate_meshes", bool),
                        ("is_sequence", bool),
                    ],
            },
        ".dae" :
            {
                "name" : "Collada",
                "op" : bpy.ops.wm.collada_import,
                "args" :
                    [
                        ("import_units", bool),
                        ("fix_orientation", bool),
                        ("find_chains", bool),
                        ("auto_connect", bool),
                        ("min_chain_length", limit_int(0, None)),
                        ("keep_bind_info", bool),
                    ],
            },
        ".fbx" :
            {
                "name" : "FBX",
                "op" : bpy.ops.import_scene.fbx,
                "args" :
                    [
                        ("axis_forward", valid_axis),
                        ("axis_up", valid_axis),
                        ("directory", str),
                        ("use_manual_orientation", bool),
                        ("global_scale", limit_float(0.001, 1000)),
                        ("bake_space_transform", bool),
                        ("use_custom_normals", bool),
                        ("use_image_search", bool),
                        ("use_alpha_decals", bool),
                        ("decal_offset", limit_float(0, 1)),
                        ("use_anim", bool),
                        ("anim_offset", float),
                        ("use_custom_props", bool),
                        ("use_custom_props_enum_as_string", bool),
                        ("ignore_leaf_bones", bool),
                        ("force_connect_children", bool),
                        ("automatic_bone_orientation", bool),
                        ("primary_bone_axis", valid_axis),
                        ("secondary_bone_axis", valid_axis),
                        ("use_prepost_rot", bool),
                    ],
            },
        ".obj" :
            {
                "name" : "OBJ",
                "op" : bpy.ops.import_scene.obj,
                "args" :
                    [
                        ("axis_forward", valid_axis),
                        ("axis_up", valid_axis),
                        ("use_edges", bool),
                        ("use_smooth_groups", bool),
                        ("use_split_objects", bool),
                        ("use_split_groups", bool),
                        ("use_groups_as_vgroups", bool),
                        ("use_image_search", bool),
                        ("split_mode", limit_enum({"OFF", "ON"})),
                        ("global_clamp_size", limit_float(0, 1000)),
                    ],
            },
        ".ply" :
            {
                "name" : "PLY",
                "op" : bpy.ops.import_mesh.ply,
                "args" :
                    [
                        ("directory", str),
                        # ("files", ?),
                    ],
            },
        ".stl" :
            {
                "name" : "STL",
                "op" : bpy.ops.import_mesh.stl,
                "args" :
                    [
                        ("axis_forward", valid_axis),
                        ("axis_up", valid_axis),
                        # ("files", ?),
                        ("directory", str),
                        ("global_scale", limit_float(1e-6, 1e6)),
                        ("use_scene_unit", bool),
                        ("use_facet_normal", bool),
                    ],
            },
        ".x3d" :
            {
                "name" : "X3D",
                "op" : bpy.ops.import_scene.x3d,
                "args" :
                    [
                        ("axis_forward", valid_axis),
                        ("axis_up", valid_axis),
                    ],
            },
    }

getext = lambda item : os.path.splitext(item)[1].lower()

#+
# Mainline
#-

infile = os.getenv("IMPORT_infile")
outfile = os.getenv("IMPORT_outfile")
existing_action = os.getenv("IMPORT_existing")
scale_factor = os.getenv("IMPORT_scale", "")
importer_args_strs = []
i = 0
while True :
    i += 1
    arg = os.getenv("IMPORT_arg_%d" % i)
    if arg == None :
        break
    importer_args_strs.append(arg)
#end while

postexec = os.getenv("IMPORT_postexec", "")
preexec = os.getenv("IMPORT_preexec", "")
if scale_factor != "" :
    try :
        scale_factor = float(scale_factor)
        if scale_factor <= 0.0 :
            raise ValueError
        #end if
    except ValueError :
        scale_factor = None
    #end try
    if scale_factor == None :
        raise getopt.GetoptError("bad --scale factor")
    #end if
else :
    scale_factor = None
#end if
template = os.getenv("IMPORT_template", "")
if template != "" :
    valid_templates = set()
    for dir in bpy.utils.app_template_paths() :
        valid_templates |= set(os.listdir(dir))
    #end for
    if template not in valid_templates :
        raise getopt.GetoptError \
          (
                "invalid template %s not found among those currently installed: %s"
            %
                (repr(template), repr(sorted(valid_templates)))
          )
    #end if
#end if
if os.path.isdir(outfile) :
    outfile = os.path.join(outfile, os.path.splitext(os.path.split(infile)[1])[0] + ".blend")
elif not outfile.endswith(".blend") :
    raise getopt.GetoptError("output file name must end with .blend")
#end if
if existing_action != "overwrite" and os.path.exists(outfile) :
    raise getopt.GetoptError("output %s already exists" % repr(outfile))
#end if

tmpdir = None

infilext = getext(infile)
if infilext in (".zip", ".7z", ".rar") :
    tmpdir = tempfile.mkdtemp(prefix = "blender_import")
    subprocess.check_call(args = ("unar", "-D", infile, "-o", tmpdir))
    modelsdir = os.path.join(tmpdir, "models")
    if not os.path.isdir(modelsdir) :
        modelsdir = tmpdir
    #end if
    use_infile = None
    importer = None
    for item in os.listdir(modelsdir) :
        infilext = getext(item)
        if infilext in importers :
            modelfile = os.path.join(modelsdir, item)
            if os.path.isfile(modelfile) :
                if use_infile != None :
                    raise RuntimeError \
                      (
                            "multiple importable files present in %s: %s, %s"
                        %
                            (repr(infile), repr(use_infile), repr(modelfile))
                      )
                #end if
                use_infile = modelfile
                importer = importers[infilext]
            #end if
        #end if
    #end for
    if use_infile == None :
        raise RuntimeError("no importable file found in in %s" % repr(infile))
    #end if
else :
    if infilext in importers :
        importer = importers[infilext]
        use_infile = infile
    else :
        raise getopt.GetoptError("input filename %s extension is not recognized" % infile)
    #end if
#end if

importer_arg_defs = dict((item[0], item[1]) for item in importer["args"])
importer_args = {}
for arg in importer_args_strs :
    value = arg.split("=", 1)
    if len(value) != 2 :
        raise getopt.GetoptError("bad import arg %s" % repr(arg))
    #end if
    keyword, value = value
    if keyword not in importer_arg_defs :
        raise getopt.GetoptError \
          (
                "unrecognized arg keyword %s for %s importer"
            %
                (repr(keyword), importer["name"])
          )
    #end if
    if keyword in importer_args :
        raise getopt.GetoptError("duplicate arg keyword %s" % repr(keyword))
    #end if
    conv = importer_arg_defs[keyword]
    fail = None
    try :
        importer_args[keyword] = conv(value)
    except (TypeError, ValueError) as why :
        fail = getopt.GetoptError \
          (
            "value for %s arg not of type %s -- %s" % (keyword, conv.__name__, str(why))
          )
    #end try
    if fail != None :
        raise fail
    #end if
#end for

bpy.ops.wm.read_homefile(app_template = template)
objs = list(obj for obj in bpy.data.objects if obj.type != "CAMERA")
for obj in objs :
    bpy.data.objects.remove(obj)
#end for
if preexec != "" :
    exec(preexec)
#end if
importer["op"](filepath = use_infile, **importer_args)
if scale_factor != None :
    bpy.ops.transform.resize(value = (scale_factor, scale_factor, scale_factor))
#end if
for image in bpy.data.images :
    image.pack()
#end for
if postexec != "" :
    exec(postexec)
#end if
bpy.ops.wm.save_as_mainfile(filepath = outfile)
if tmpdir != None :
    shutil.rmtree(tmpdir)
#end if

EOD
)
